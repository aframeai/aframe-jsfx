{"version":3,"sources":["node_modules/loov-jsfx/jsfx.js","index.js"],"names":["AFRAME","Error","registerComponent","multiple","schema","src","type","sound","event","default","update","old","data","config","JSON","parse","THREE","Cache","files","sounds","Object","keys","oneOf","el","setAttribute","jsfx","Sounds","playing","removeEvent","addEvent","playSound","eventname","id","addEventListener","name","removeEventListener","pause","remove","play"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"aframe-jsfx.js","sourceRoot":"..","sourcesContent":["(function(root, factory) {\n\tif (typeof module === \"object\" && typeof module.exports === \"object\") {\n\t\tmodule.exports = factory();\n\t} else {\n\t\troot.jsfx = factory();\n\t}\n}(this, function() {\n\t'use strict';\n\n\tvar chr = String.fromCharCode;\n\tvar TAU = +Math.PI * 2;\n\tvar bitsPerSample = 16 | 0;\n\tvar numChannels = 1 | 0;\n\tvar sin = Math.sin;\n\tvar pow = Math.pow;\n\tvar abs = Math.abs;\n\tvar EPSILON = 0.000001;\n\n\tvar jsfx = {};\n\tvar AudioContext = window.AudioContext || window.webkitAudioContext;\n\n\tjsfx.SampleRate = 0 | 0;\n\tjsfx.Sec = 0 | 0;\n\n\tjsfx.SetSampleRate = function(sampleRate) {\n\t\tjsfx.SampleRate = sampleRate | 0;\n\t\tjsfx.Sec = sampleRate | 0;\n\t};\n\tjsfx.SetSampleRate(getDefaultSampleRate());\n\n\t// MAIN API\n\n\t// Creates a new Audio object based on the params\n\t// params can be a params generating function or the actual parameters\n\tjsfx.Sound = function(params) {\n\t\tvar processor = new Processor(params, jsfx.DefaultModules);\n\t\tvar block = createFloatArray(processor.getSamplesLeft());\n\t\tprocessor.generate(block);\n\t\treturn CreateAudio(block);\n\t};\n\n\t// Same as Sounds, but avoids locking the browser for too long\n\t// in case you have a large amount of sounds to generate\n\tjsfx.Sounds = function(library, ondone, onprogress) {\n\t\tvar audio = {};\n\t\tvar player = {};\n\t\tplayer._audio = audio;\n\n\t\tvar toLoad = [];\n\n\t\t// create playing functions\n\t\tmap_object(library, function(_, name) {\n\t\t\tplayer[name] = function() {\n\t\t\t\tif (typeof audio[name] !== \"undefined\") {\n\t\t\t\t\taudio[name].currentTime = 0.0;\n\t\t\t\t\taudio[name].play();\n\t\t\t\t}\n\t\t\t};\n\t\t\ttoLoad.push(name);\n\t\t});\n\n\t\tvar loaded = 0,\n\t\t\ttotal = toLoad.length;\n\n\t\tfunction next() {\n\t\t\tif (toLoad.length == 0) {\n\t\t\t\tondone && ondone(sounds);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar name = toLoad.shift();\n\t\t\taudio[name] = jsfx.Sound(library[name]);\n\t\t\tloaded++;\n\t\t\tonprogress && onprogress(name, loaded, total);\n\n\t\t\twindow.setTimeout(next, 30);\n\t\t}\n\t\tnext();\n\n\t\treturn player;\n\t}\n\n\t// SoundsImmediate takes a named set of params, and generates multiple\n\t// sound objects at once.\n\tjsfx.SoundsImmediate = function(library) {\n\t\tvar audio = {};\n\t\tvar player = {};\n\t\tplayer._audio = audio;\n\t\tmap_object(library, function(params, name) {\n\t\t\taudio[name] = jsfx.Sound(params);\n\t\t\tplayer[name] = function() {\n\t\t\t\tif (typeof audio[name] !== \"undefined\") {\n\t\t\t\t\taudio[name].currentTime = 0.0;\n\t\t\t\t\taudio[name].play();\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t\treturn player;\n\t};\n\n\t// FloatBuffer creates a FloatArray filled with audio\n\tjsfx.FloatBuffer = function(params, modules) {\n\t\tvar processor = new Processor(params, jsfx.DefaultModules);\n\t\tvar block = createFloatArray(processor.getSamplesLeft());\n\t\tprocessor.generate(block);\n\t\treturn block;\n\t};\n\n\tif (typeof AudioContext !== \"undefined\") {\n\t\t// Node creates a new AudioContext ScriptProcessor that outputs the\n\t\t// sound. It will automatically disconnect, unless otherwise specified.\n\t\tjsfx.Node = function(audioContext, params, modules, bufferSize, stayConnected) {\n\t\t\tvar node = audioContext.createScriptProcessor(bufferSize, 0, 1);\n\t\t\tvar gen = new Processor(params, modules || jsfx.DefaultModules);\n\t\t\tnode.onaudioprocess = function(ev) {\n\t\t\t\tvar block = ev.outputBuffer.getChannelData(0);\n\t\t\t\tgen.generate(block);\n\t\t\t\tif (!stayConnected && gen.finished) {\n\t\t\t\t\t// we need to do an async disconnect, otherwise Chrome may\n\t\t\t\t\t// glitch\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tnode.disconnect();\n\t\t\t\t\t}, 30);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\t// AudioBuffer creates a buffer filled with the proper audio\n\t\t// This is useful, when you want to use AudioContext.BufferSource\n\t\tjsfx.AudioBuffer = function(audioContext, params, modules) {\n\t\t\tvar processor = new Processor(params, modules || jsfx.DefaultModules);\n\t\t\tvar buffer = audioContext.createBuffer(numChannels, processor.getSamplesLeft(), jsfx.SampleRate);\n\t\t\tvar block = buffer.getChannelData(0);\n\t\t\tprocessor.generate(block);\n\t\t\treturn buffer;\n\t\t};\n\n\t\t// Live creates an managed AudioContext for playing.\n\t\t// This is useful, when you want to use procedurally generated sounds.\n\t\tjsfx.Live = function(library, modules, BufferSize) {\n\t\t\t//TODO: add limit for number of notes played at the same time\n\t\t\tBufferSize = BufferSize || 2048;\n\t\t\tvar player = {};\n\n\t\t\tvar context = new AudioContext();\n\t\t\tvar volume = context.createGain();\n\t\t\tvolume.connect(context.destination);\n\n\t\t\tplayer._context = context;\n\t\t\tplayer._volume = volume;\n\n\t\t\tmap_object(library, function(params, name) {\n\t\t\t\tplayer[name] = function() {\n\t\t\t\t\tvar node = jsfx.Node(context, params, modules, BufferSize);\n\t\t\t\t\tnode.connect(volume);\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tplayer._close = function() {\n\t\t\t\tcontext.close();\n\t\t\t};\n\n\t\t\tplayer._play = function(params) {\n\t\t\t\tvar node = jsfx.Node(context, params, modules, BufferSize);\n\t\t\t\tnode.connect(volume);\n\t\t\t};\n\n\t\t\treturn player;\n\t\t}\n\t} else {\n\t\tjsfx.Live = jsfx.Sounds;\n\t}\n\n\t// SOUND GENERATION\n\tjsfx.Module = {};\n\n\t// generators\n\tjsfx.G = {};\n\n\tvar stage = jsfx.stage = {\n\t\tPhaseSpeed: 0,\n\t\tPhaseSpeedMod: 10,\n\t\tGenerator: 20,\n\t\tSampleMod: 30,\n\t\tVolume: 40\n\t};\n\n\tfunction byStage(a, b) {\n\t\treturn a.stage - b.stage;\n\t}\n\n\tjsfx.InitDefaultParams = InitDefaultParams;\n\n\tfunction InitDefaultParams(params, modules) {\n\t\t// setup modules\n\t\tfor (var i = 0; i < modules.length; i += 1) {\n\t\t\tvar M = modules[i];\n\t\t\tvar P = params[M.name] || {};\n\n\t\t\t// add missing parameters\n\t\t\tmap_object(M.params, function(def, name) {\n\t\t\t\tif (typeof P[name] === 'undefined') {\n\t\t\t\t\tP[name] = def.D;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparams[M.name] = P;\n\t\t}\n\t}\n\n\t// Generates a stateful sound effect processor\n\t// params can be a function that creates a parameter set\n\tjsfx.Processor = Processor;\n\n\tfunction Processor(params, modules) {\n\t\tparams = params || {};\n\t\tmodules = modules || jsfx.DefaultModules;\n\n\t\tif (typeof params === 'function') {\n\t\t\tparams = params();\n\t\t} else {\n\t\t\tparams = JSON.parse(JSON.stringify(params))\n\t\t}\n\t\tthis.finished = false;\n\n\t\tthis.state = {\n\t\t\tSampleRate: params.SampleRate || jsfx.SampleRate\n\t\t};\n\n\t\t// sort modules\n\t\tmodules = modules.slice();\n\t\tmodules.sort(byStage)\n\t\tthis.modules = modules;\n\n\t\t// init missing params\n\t\tInitDefaultParams(params, modules);\n\n\t\t// setup modules\n\t\tfor (var i = 0; i < this.modules.length; i += 1) {\n\t\t\tvar M = this.modules[i];\n\t\t\tthis.modules[i].setup(this.state, params[M.name]);\n\t\t}\n\t}\n\tProcessor.prototype = {\n\t\t//TODO: see whether this can be converted to a module\n\t\tgenerate: function(block) {\n\t\t\tfor (var i = 0 | 0; i < block.length; i += 1) {\n\t\t\t\tblock[i] = 0;\n\t\t\t}\n\t\t\tif (this.finished) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar $ = this.state,\n\t\t\t\tN = block.length | 0;\n\t\t\tfor (var i = 0; i < this.modules.length; i += 1) {\n\t\t\t\tvar M = this.modules[i];\n\t\t\t\tvar n = M.process($, block.subarray(0, N)) | 0;\n\t\t\t\tN = Math.min(N, n);\n\t\t\t}\n\t\t\tif (N < block.length) {\n\t\t\t\tthis.finished = true;\n\t\t\t}\n\t\t\tfor (var i = N; i < block.length; i++) {\n\t\t\t\tblock[i] = 0;\n\t\t\t}\n\t\t},\n\t\tgetSamplesLeft: function() {\n\t\t\tvar samples = 0;\n\t\t\tfor (var i = 0; i < this.state.envelopes.length; i += 1) {\n\t\t\t\tsamples += this.state.envelopes[i].N;\n\t\t\t}\n\t\t\tif (samples === 0) {\n\t\t\t\tsamples = 3 * this.state.SampleRate;\n\t\t\t}\n\t\t\treturn samples;\n\t\t}\n\t};\n\n\t// Frequency\n\tjsfx.Module.Frequency = {\n\t\tname: 'Frequency',\n\t\tparams: {\n\t\t\t/* beautify preserve:start */\n\t\t\tStart: { L:30, H:1800, D:440  },\n\n\t\t\tMin: { L:30, H:1800, D:30    },\n\t\t\tMax: { L:30, H:1800, D:1800  },\n\n\t\t\tSlide:      { L:-1, H:1, D:0 },\n\t\t\tDeltaSlide: { L:-1, H:1, D:0 },\n\n\t\t\tRepeatSpeed:  { L:0, H: 3.0, D: 0 },\n\n\t\t\tChangeAmount: { L:-12, H:12, D:0 },\n\t\t\tChangeSpeed : { L:  0, H:1,  D:0 }\n\t\t\t/* beautify preserve:end */\n\t\t},\n\t\tstage: stage.PhaseSpeed,\n\t\tsetup: function($, P) {\n\t\t\tvar SR = $.SampleRate;\n\n\t\t\t$.phaseParams = P;\n\n\t\t\t$.phaseSpeed = P.Start * TAU / SR;\n\t\t\t$.phaseSpeedMax = P.Max * TAU / SR;\n\t\t\t$.phaseSpeedMin = P.Min * TAU / SR;\n\n\t\t\t$.phaseSpeedMin = Math.min($.phaseSpeedMin, $.phaseSpeed);\n\t\t\t$.phaseSpeedMax = Math.max($.phaseSpeedMax, $.phaseSpeed);\n\n\t\t\t$.phaseSlide = 1.0 + pow(P.Slide, 3.0) * 64.0 / SR;\n\t\t\t$.phaseDeltaSlide = pow(P.DeltaSlide, 3.0) / (SR * 1000);\n\n\t\t\t$.repeatTime = 0;\n\t\t\t$.repeatLimit = Infinity;\n\t\t\tif (P.RepeatSpeed > 0) {\n\t\t\t\t$.repeatLimit = P.RepeatSpeed * SR;\n\t\t\t}\n\n\t\t\t$.arpeggiatorTime = 0;\n\t\t\t$.arpeggiatorLimit = P.ChangeSpeed * SR;\n\t\t\tif (P.ChangeAmount == 0) {\n\t\t\t\t$.arpeggiatorLimit = Infinity;\n\t\t\t}\n\t\t\t$.arpeggiatorMod = 1 + P.ChangeAmount / 12.0;\n\t\t},\n\t\tprocess: function($, block) {\n\t\t\tvar speed = +$.phaseSpeed,\n\t\t\t\tmin = +$.phaseSpeedMin,\n\t\t\t\tmax = +$.phaseSpeedMax,\n\t\t\t\tslide = +$.phaseSlide,\n\t\t\t\tdeltaSlide = +$.phaseDeltaSlide;\n\n\t\t\tvar repeatTime = $.repeatTime,\n\t\t\t\trepeatLimit = $.repeatLimit;\n\n\t\t\tvar arpTime = $.arpeggiatorTime,\n\t\t\t\tarpLimit = $.arpeggiatorLimit,\n\t\t\t\tarpMod = $.arpeggiatorMod;\n\n\t\t\tfor (var i = 0; i < block.length; i++) {\n\t\t\t\tslide += deltaSlide;\n\t\t\t\tspeed *= slide;\n\t\t\t\tspeed = speed < min ? min : speed > max ? max : speed;\n\n\t\t\t\tif (repeatTime > repeatLimit) {\n\t\t\t\t\tthis.setup($, $.phaseParams);\n\t\t\t\t\treturn i + this.process($, block.subarray(i)) - 1;\n\t\t\t\t}\n\t\t\t\trepeatTime++;\n\n\t\t\t\tif (arpTime > arpLimit) {\n\t\t\t\t\tspeed *= arpMod;\n\t\t\t\t\tarpTime = 0;\n\t\t\t\t\tarpLimit = Infinity;\n\t\t\t\t}\n\t\t\t\tarpTime++;\n\n\t\t\t\tblock[i] += speed;\n\t\t\t}\n\n\t\t\t$.repeatTime = repeatTime;\n\t\t\t$.arpeggiatorTime = arpTime;\n\t\t\t$.arpeggiatorLimit = arpLimit;\n\n\t\t\t$.phaseSpeed = speed;\n\t\t\t$.phaseSlide = slide;\n\n\t\t\treturn block.length;\n\t\t}\n\t};\n\n\t// Vibrato\n\tjsfx.Module.Vibrato = {\n\t\tname: 'Vibrato',\n\t\tparams: {\n\t\t\t/* beautify preserve:start */\n\t\t\tDepth:      {L: 0, H:1, D:0},\n\t\t\tDepthSlide: {L:-1, H:1, D:0},\n\n\t\t\tFrequency:      {L:  0.01, H:48, D:0},\n\t\t\tFrequencySlide: {L: -1.00, H: 1, D:0}\n\t\t\t/* beautify preserve:end */\n\t\t},\n\t\tstage: stage.PhaseSpeedMod,\n\t\tsetup: function($, P) {\n\t\t\tvar SR = $.SampleRate;\n\t\t\t$.vibratoPhase = 0;\n\t\t\t$.vibratoDepth = P.Depth;\n\t\t\t$.vibratoPhaseSpeed = P.Frequency * TAU / SR;\n\n\t\t\t$.vibratoPhaseSpeedSlide = 1.0 + pow(P.FrequencySlide, 3.0) * 3.0 / SR;\n\t\t\t$.vibratoDepthSlide = P.DepthSlide / SR;\n\t\t},\n\t\tprocess: function($, block) {\n\t\t\tvar phase = +$.vibratoPhase,\n\t\t\t\tdepth = +$.vibratoDepth,\n\t\t\t\tspeed = +$.vibratoPhaseSpeed,\n\t\t\t\tslide = +$.vibratoPhaseSpeedSlide,\n\t\t\t\tdepthSlide = +$.vibratoDepthSlide;\n\n\t\t\tif ((depth == 0) && (depthSlide <= 0)) {\n\t\t\t\treturn block.length;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < block.length; i++) {\n\t\t\t\tphase += speed;\n\t\t\t\tif (phase > TAU) {\n\t\t\t\t\tphase -= TAU\n\t\t\t\t};\n\t\t\t\tblock[i] += block[i] * sin(phase) * depth;\n\n\t\t\t\tspeed *= slide;\n\t\t\t\tdepth += depthSlide;\n\t\t\t\tdepth = clamp1(depth);\n\t\t\t}\n\n\t\t\t$.vibratoPhase = phase;\n\t\t\t$.vibratoDepth = depth;\n\t\t\t$.vibratoPhaseSpeed = speed;\n\t\t\treturn block.length;\n\t\t}\n\t};\n\n\t// Generator\n\tjsfx.Module.Generator = {\n\t\tname: 'Generator',\n\t\tparams: {\n\t\t\t/* beautify preserve:start */\n\t\t\t// C = choose\n\t\t\tFunc: {C: jsfx.G, D:'square'},\n\n\t\t\tA: {L: 0, H: 1, D: 0},\n\t\t\tB: {L: 0, H: 1, D: 0},\n\n\t\t\tASlide: {L: -1, H: 1, D: 0},\n\t\t\tBSlide: {L: -1, H: 1, D: 0}\n\t\t\t/* beautify preserve:end */\n\t\t},\n\t\tstage: stage.Generator,\n\t\tsetup: function($, P) {\n\t\t\t$.generatorPhase = 0;\n\n\t\t\tif (typeof P.Func === 'string') {\n\t\t\t\t$.generator = jsfx.G[P.Func];\n\t\t\t} else {\n\t\t\t\t$.generator = P.Func;\n\t\t\t}\n\t\t\tif (typeof $.generator === 'object') {\n\t\t\t\t$.generator = $.generator.create();\n\t\t\t}\n\t\t\tassert(typeof $.generator === 'function', 'generator must be a function')\n\n\t\t\t$.generatorA = P.A;\n\t\t\t$.generatorASlide = P.ASlide;\n\t\t\t$.generatorB = P.B;\n\t\t\t$.generatorBSlide = P.BSlide;\n\t\t},\n\t\tprocess: function($, block) {\n\t\t\treturn $.generator($, block);\n\t\t}\n\t};\n\n\t// Karplus Strong algorithm for string sound\n\tvar GuitarBufferSize = 1 << 16;\n\tjsfx.Module.Guitar = {\n\t\tname: 'Guitar',\n\t\tparams: {\n\t\t\t/* beautify preserve:start */\n\t\t\tA: {L:0.0, H:1.0, D: 1},\n\t\t\tB: {L:0.0, H:1.0, D: 1},\n\t\t\tC: {L:0.0, H:1.0, D: 1}\n\t\t\t/* beautify preserve:end */\n\t\t},\n\t\tstage: stage.Generator,\n\t\tsetup: function($, P) {\n\t\t\t$.guitarA = P.A;\n\t\t\t$.guitarB = P.B;\n\t\t\t$.guitarC = P.C;\n\n\t\t\t$.guitarBuffer = createFloatArray(GuitarBufferSize);\n\t\t\t$.guitarHead = 0;\n\t\t\tvar B = $.guitarBuffer;\n\t\t\tfor (var i = 0; i < B.length; i++) {\n\t\t\t\tB[i] = Math.random() * 2 - 1;\n\t\t\t}\n\t\t},\n\t\tprocess: function($, block) {\n\t\t\tvar BS = GuitarBufferSize,\n\t\t\t\tBM = BS - 1;\n\n\t\t\tvar A = +$.guitarA,\n\t\t\t\tB = +$.guitarB,\n\t\t\t\tC = +$.guitarC;\n\t\t\tvar T = A + B + C;\n\t\t\tvar h = $.guitarHead;\n\n\t\t\tvar buffer = $.guitarBuffer;\n\t\t\tfor (var i = 0; i < block.length; i++) {\n\t\t\t\t// buffer size\n\t\t\t\tvar n = (TAU / block[i]) | 0;\n\t\t\t\tn = n > BS ? BS : n;\n\n\t\t\t\t// tail\n\t\t\t\tvar t = ((h - n) + BS) & BM;\n\t\t\t\tbuffer[h] =\n\t\t\t\t\t(buffer[(t - 0 + BS) & BM] * A +\n\t\t\t\t\t\tbuffer[(t - 1 + BS) & BM] * B +\n\t\t\t\t\t\tbuffer[(t - 2 + BS) & BM] * C) / T;\n\n\t\t\t\tblock[i] = buffer[h];\n\t\t\t\th = (h + 1) & BM;\n\t\t\t}\n\n\t\t\t$.guitarHead = h;\n\t\t\treturn block.length;\n\t\t}\n\t}\n\n\t// Low/High-Pass Filter\n\tjsfx.Module.Filter = {\n\t\tname: 'Filter',\n\t\tparams: {\n\t\t\t/* beautify preserve:start */\n\t\t\tLP:          {L: 0, H:1, D:1},\n\t\t\tLPSlide:     {L:-1, H:1, D:0},\n\t\t\tLPResonance: {L: 0, H:1, D:0},\n\t\t\tHP:          {L: 0, H:1, D:0},\n\t\t\tHPSlide:     {L:-1, H:1, D:0}\n\t\t\t/* beautify preserve:end */\n\t\t},\n\t\tstage: stage.SampleMod + 0,\n\t\tsetup: function($, P) {\n\t\t\t$.FilterEnabled = (P.HP > EPSILON) || (P.LP < 1 - EPSILON);\n\n\t\t\t$.LPEnabled = P.LP < 1 - EPSILON;\n\t\t\t$.LP = pow(P.LP, 3.0) / 10;\n\t\t\t$.LPSlide = 1.0 + P.LPSlide * 100 / $.SampleRate;\n\t\t\t$.LPPos = 0;\n\t\t\t$.LPPosSlide = 0;\n\n\t\t\t$.LPDamping = 5.0 / (1.0 + pow(P.LPResonance, 2) * 20) * (0.01 + P.LP);\n\t\t\t$.LPDamping = 1.0 - Math.min($.LPDamping, 0.8);\n\n\t\t\t$.HP = pow(P.HP, 2.0) / 10;\n\t\t\t$.HPPos = 0;\n\t\t\t$.HPSlide = 1.0 + P.HPSlide * 100 / $.SampleRate;\n\t\t},\n\t\tenabled: function($) {\n\t\t\treturn $.FilterEnabled;\n\t\t},\n\t\tprocess: function($, block) {\n\t\t\tif (!this.enabled($)) {\n\t\t\t\treturn block.length;\n\t\t\t}\n\n\t\t\tvar lp = +$.LP;\n\t\t\tvar lpPos = +$.LPPos;\n\t\t\tvar lpPosSlide = +$.LPPosSlide;\n\t\t\tvar lpSlide = +$.LPSlide;\n\t\t\tvar lpDamping = +$.LPDamping;\n\t\t\tvar lpEnabled = +$.LPEnabled;\n\n\t\t\tvar hp = +$.HP;\n\t\t\tvar hpPos = +$.HPPos;\n\t\t\tvar hpSlide = +$.HPSlide;\n\n\t\t\tfor (var i = 0; i < block.length; i++) {\n\t\t\t\tif ((hp > EPSILON) || (hp < -EPSILON)) {\n\t\t\t\t\thp *= hpSlide;\n\t\t\t\t\thp = hp < EPSILON ? EPSILON : hp > 0.1 ? 0.1 : hp;\n\t\t\t\t}\n\n\t\t\t\tvar lpPos_ = lpPos;\n\n\t\t\t\tlp *= lpSlide;\n\t\t\t\tlp = lp < 0 ? lp = 0 : lp > 0.1 ? 0.1 : lp;\n\n\t\t\t\tvar sample = block[i];\n\t\t\t\tif (lpEnabled) {\n\t\t\t\t\tlpPosSlide += (sample - lpPos) * lp;\n\t\t\t\t\tlpPosSlide *= lpDamping;\n\t\t\t\t} else {\n\t\t\t\t\tlpPos = sample;\n\t\t\t\t\tlpPosSlide = 0;\n\t\t\t\t}\n\t\t\t\tlpPos += lpPosSlide;\n\n\t\t\t\thpPos += lpPos - lpPos_;\n\t\t\t\thpPos *= 1.0 - hp;\n\n\t\t\t\tblock[i] = hpPos;\n\t\t\t}\n\n\t\t\t$.LPPos = lpPos;\n\t\t\t$.LPPosSlide = lpPosSlide;\n\t\t\t$.LP = lp;\n\t\t\t$.HP = hp;\n\t\t\t$.HPPos = hpPos;\n\n\t\t\treturn block.length;\n\t\t}\n\t};\n\n\t// Phaser Effect\n\tvar PhaserBufferSize = 1 << 10;\n\tjsfx.Module.Phaser = {\n\t\tname: 'Phaser',\n\t\tparams: {\n\t\t\t/* beautify preserve:start */\n\t\t\tOffset: {L:-1, H:1, D:0},\n\t\t\tSweep:  {L:-1, H:1, D:0}\n\t\t\t/* beautify preserve:end */\n\t\t},\n\t\tstage: stage.SampleMod + 1,\n\t\tsetup: function($, P) {\n\t\t\t$.phaserBuffer = createFloatArray(PhaserBufferSize);\n\t\t\t$.phaserPos = 0;\n\t\t\t$.phaserOffset = pow(P.Offset, 2.0) * (PhaserBufferSize - 4);\n\t\t\t$.phaserOffsetSlide = pow(P.Sweep, 3.0) * 4000 / $.SampleRate;\n\t\t},\n\t\tenabled: function($) {\n\t\t\treturn (abs($.phaserOffsetSlide) > EPSILON) ||\n\t\t\t\t(abs($.phaserOffset) > EPSILON);\n\t\t},\n\t\tprocess: function($, block) {\n\t\t\tif (!this.enabled($)) {\n\t\t\t\treturn block.length;\n\t\t\t}\n\n\t\t\tvar BS = PhaserBufferSize,\n\t\t\t\tBM = BS - 1;\n\n\t\t\tvar buffer = $.phaserBuffer,\n\t\t\t\tpos = $.phaserPos | 0,\n\t\t\t\toffset = +$.phaserOffset,\n\t\t\t\toffsetSlide = +$.phaserOffsetSlide;\n\n\t\t\tfor (var i = 0; i < block.length; i++) {\n\t\t\t\toffset += offsetSlide;\n\t\t\t\t//TODO: check whether this is correct\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\toffset = -offset;\n\t\t\t\t\toffsetSlide = -offsetSlide;\n\t\t\t\t}\n\t\t\t\tif (offset > BM) {\n\t\t\t\t\toffset = BM;\n\t\t\t\t\toffsetSlide = 0;\n\t\t\t\t}\n\n\t\t\t\tbuffer[pos] = block[i];\n\t\t\t\tvar p = (pos - (offset | 0) + BS) & BM;\n\t\t\t\tblock[i] += buffer[p];\n\n\t\t\t\tpos = ((pos + 1) & BM) | 0;\n\t\t\t}\n\n\t\t\t$.phaserPos = pos;\n\t\t\t$.phaserOffset = offset;\n\t\t\treturn block.length;\n\t\t}\n\t};\n\n\t// Volume dynamic control with Attack-Sustain-Decay\n\t//   ATTACK  | 0              - Volume + Punch\n\t//   SUSTAIN | Volume + Punch - Volume\n\t//   DECAY   | Volume         - 0\n\tjsfx.Module.Volume = {\n\t\tname: 'Volume',\n\t\tparams: {\n\t\t\t/* beautify preserve:start */\n\t\t\tMaster:  { L: 0, H: 1, D: 0.5 },\n\t\t\tAttack:  { L: 0.001, H: 1, D: 0.01 },\n\t\t\tSustain: { L: 0, H: 2, D: 0.3 },\n\t\t\tPunch:   { L: 0, H: 3, D: 1.0 },\n\t\t\tDecay:   { L: 0.001, H: 2, D: 1.0 }\n\t\t\t/* beautify preserve:end */\n\t\t},\n\t\tstage: stage.Volume,\n\t\tsetup: function($, P) {\n\t\t\tvar SR = $.SampleRate;\n\t\t\tvar V = P.Master;\n\t\t\tvar VP = V * (1 + P.Punch);\n\t\t\t$.envelopes = [\n\t\t\t\t// S = start volume, E = end volume, N = duration in samples\n\t\t\t\t{\n\t\t\t\t\tS: 0,\n\t\t\t\t\tE: V,\n\t\t\t\t\tN: (P.Attack * SR) | 0\n\t\t\t\t}, // Attack\n\t\t\t\t{\n\t\t\t\t\tS: VP,\n\t\t\t\t\tE: V,\n\t\t\t\t\tN: (P.Sustain * SR) | 0\n\t\t\t\t}, // Sustain\n\t\t\t\t{\n\t\t\t\t\tS: V,\n\t\t\t\t\tE: 0,\n\t\t\t\t\tN: (P.Decay * SR) | 0\n\t\t\t\t} // Decay\n\t\t\t];\n\t\t\t// G = volume gradient\n\t\t\tfor (var i = 0; i < $.envelopes.length; i += 1) {\n\t\t\t\tvar e = $.envelopes[i];\n\t\t\t\te.G = (e.E - e.S) / e.N;\n\t\t\t}\n\t\t},\n\t\tprocess: function($, block) {\n\t\t\tvar i = 0;\n\t\t\twhile (($.envelopes.length > 0) && (i < block.length)) {\n\t\t\t\tvar E = $.envelopes[0];\n\t\t\t\tvar vol = E.S,\n\t\t\t\t\tgrad = E.G;\n\n\t\t\t\tvar N = Math.min(block.length - i, E.N) | 0;\n\t\t\t\tvar end = (i + N) | 0;\n\t\t\t\tfor (; i < end; i += 1) {\n\t\t\t\t\tblock[i] *= vol;\n\t\t\t\t\tvol += grad;\n\t\t\t\t\tvol = clamp(vol, 0, 10);\n\t\t\t\t}\n\t\t\t\tE.S = vol;\n\t\t\t\tE.N -= N;\n\t\t\t\tif (E.N <= 0) {\n\t\t\t\t\t$.envelopes.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t};\n\n\t// PRESETS\n\n\tjsfx.DefaultModules = [\n\t\tjsfx.Module.Frequency,\n\t\tjsfx.Module.Vibrato,\n\t\tjsfx.Module.Generator,\n\t\tjsfx.Module.Filter,\n\t\tjsfx.Module.Phaser,\n\t\tjsfx.Module.Volume\n\t];\n\tjsfx.DefaultModules.sort(byStage);\n\n\tjsfx.EmptyParams = EmptyParams;\n\n\tfunction EmptyParams() {\n\t\treturn map_object(jsfx.Module, function() {\n\t\t\treturn {}\n\t\t});\n\t}\n\n\tjsfx._RemoveEmptyParams = RemoveEmptyParams;\n\n\tfunction RemoveEmptyParams(params) {\n\t\tfor (var name in params) {\n\t\t\tif (Object_keys(params[name]).length == 0) {\n\t\t\t\tdelete params[name];\n\t\t\t}\n\t\t}\n\t};\n\n\tjsfx.Preset = {\n\t\tReset: function() {\n\t\t\treturn EmptyParams();\n\t\t},\n\t\tCoin: function() {\n\t\t\tvar p = EmptyParams();\n\t\t\tp.Frequency.Start = runif(880, 660);\n\t\t\tp.Volume.Sustain = runif(0.1);\n\t\t\tp.Volume.Decay = runif(0.4, 0.1);\n\t\t\tp.Volume.Punch = runif(0.3, 0.3);\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Frequency.ChangeSpeed = runif(0.15, 0.1);\n\t\t\t\tp.Frequency.ChangeAmount = runif(8, 4);\n\t\t\t}\n\t\t\tRemoveEmptyParams(p);\n\t\t\treturn p;\n\t\t},\n\t\tLaser: function() {\n\t\t\tvar p = EmptyParams();\n\t\t\tp.Generator.Func = rchoose(['square', 'saw', 'sine']);\n\n\t\t\tif (runif() < 0.33) {\n\t\t\t\tp.Frequency.Start = runif(880, 440);\n\t\t\t\tp.Frequency.Min = runif(0.1);\n\t\t\t\tp.Frequency.Slide = runif(0.3, -0.8);\n\t\t\t} else {\n\t\t\t\tp.Frequency.Start = runif(1200, 440);\n\t\t\t\tp.Frequency.Min = p.Frequency.Start - runif(880, 440);\n\t\t\t\tif (p.Frequency.Min < 110) {\n\t\t\t\t\tp.Frequency.Min = 110;\n\t\t\t\t}\n\t\t\t\tp.Frequency.Slide = runif(0.3, -1);\n\t\t\t}\n\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Generator.A = runif(0.5);\n\t\t\t\tp.Generator.ASlide = runif(0.2);\n\t\t\t} else {\n\t\t\t\tp.Generator.A = runif(0.5, 0.4);\n\t\t\t\tp.Generator.ASlide = runif(0.7);\n\t\t\t}\n\n\t\t\tp.Volume.Sustain = runif(0.2, 0.1);\n\t\t\tp.Volume.Decay = runif(0.4);\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Volume.Punch = runif(0.3);\n\t\t\t}\n\t\t\tif (runif() < 0.33) {\n\t\t\t\tp.Phaser.Offset = runif(0.2);\n\t\t\t\tp.Phaser.Sweep = runif(0.2);\n\t\t\t}\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Filter.HP = runif(0.3);\n\t\t\t}\n\t\t\tRemoveEmptyParams(p);\n\t\t\treturn p;\n\t\t},\n\t\tExplosion: function() {\n\t\t\tvar p = EmptyParams();\n\t\t\tp.Generator.Func = 'noise';\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Frequency.Start = runif(440, 40);\n\t\t\t\tp.Frequency.Slide = runif(0.4, -0.1);\n\t\t\t} else {\n\t\t\t\tp.Frequency.Start = runif(1600, 220);\n\t\t\t\tp.Frequency.Slide = runif(-0.2, -0.2);\n\t\t\t}\n\n\t\t\tif (runif() < 0.2) {\n\t\t\t\tp.Frequency.Slide = 0;\n\t\t\t}\n\t\t\tif (runif() < 0.3) {\n\t\t\t\tp.Frequency.RepeatSpeed = runif(0.5, 0.3);\n\t\t\t}\n\n\t\t\tp.Volume.Sustain = runif(0.3, 0.1);\n\t\t\tp.Volume.Decay = runif(0.5);\n\t\t\tp.Volume.Punch = runif(0.6, 0.2);\n\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Phaser.Offset = runif(0.9, -0.3);\n\t\t\t\tp.Phaser.Sweep = runif(-0.3);\n\t\t\t}\n\n\t\t\tif (runif() < 0.33) {\n\t\t\t\tp.Frequency.ChangeSpeed = runif(0.3, 0.6);\n\t\t\t\tp.Frequency.ChangeAmount = runif(24, -12);\n\t\t\t}\n\t\t\tRemoveEmptyParams(p);\n\t\t\treturn p;\n\t\t},\n\t\tPowerup: function() {\n\t\t\tvar p = EmptyParams();\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Generator.Func = 'saw';\n\t\t\t} else {\n\t\t\t\tp.Generator.A = runif(0.6);\n\t\t\t}\n\n\t\t\tp.Frequency.Start = runif(220, 440);\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Frequency.Slide = runif(0.5, 0.2);\n\t\t\t\tp.Frequency.RepeatSpeed = runif(0.4, 0.4);\n\t\t\t} else {\n\t\t\t\tp.Frequency.Slide = runif(0.2, 0.05);\n\t\t\t\tif (runif() < 0.5) {\n\t\t\t\t\tp.Vibrato.Depth = runif(0.6, 0.1);\n\t\t\t\t\tp.Vibrato.Frequency = runif(30, 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp.Volume.Sustain = runif(0.4);\n\t\t\tp.Volume.Decay = runif(0.4, 0.1);\n\n\t\t\tRemoveEmptyParams(p);\n\t\t\treturn p;\n\t\t},\n\t\tHit: function() {\n\t\t\tvar p = EmptyParams();\n\t\t\tp.Generator.Func = rchoose(['square', 'saw', 'noise']);\n\t\t\tp.Generator.A = runif(0.6);\n\t\t\tp.Generator.ASlide = runif(1, -0.5);\n\n\t\t\tp.Frequency.Start = runif(880, 220);\n\t\t\tp.Frequency.Slide = -runif(0.4, 0.3);\n\n\t\t\tp.Volume.Sustain = runif(0.1);\n\t\t\tp.Volume.Decay = runif(0.2, 0.1);\n\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Filter.HP = runif(0.3);\n\t\t\t}\n\n\t\t\tRemoveEmptyParams(p);\n\t\t\treturn p;\n\t\t},\n\t\tJump: function() {\n\t\t\tvar p = EmptyParams();\n\t\t\tp.Generator.Func = 'square';\n\t\t\tp.Generator.A = runif(0.6);\n\n\t\t\tp.Frequency.Start = runif(330, 330);\n\t\t\tp.Frequency.Slide = runif(0.4, 0.2);\n\n\t\t\tp.Volume.Sustain = runif(0.3, 0.1);\n\t\t\tp.Volume.Decay = runif(0.2, 0.1);\n\n\t\t\tif (runif() < 0.5) {\n\t\t\t\tp.Filter.HP = runif(0.3);\n\t\t\t}\n\t\t\tif (runif() < 0.3) {\n\t\t\t\tp.Filter.LP = runif(-0.6, 1);\n\t\t\t}\n\n\t\t\tRemoveEmptyParams(p);\n\t\t\treturn p;\n\t\t},\n\t\tSelect: function() {\n\t\t\tvar p = EmptyParams();\n\t\t\tp.Generator.Func = rchoose(['square', 'saw']);\n\t\t\tp.Generator.A = runif(0.6);\n\n\t\t\tp.Frequency.Start = runif(660, 220);\n\n\t\t\tp.Volume.Sustain = runif(0.1, 0.1);\n\t\t\tp.Volume.Decay = runif(0.2);\n\n\t\t\tp.Filter.HP = 0.2;\n\t\t\tRemoveEmptyParams(p);\n\t\t\treturn p;\n\t\t},\n\t\tLucky: function() {\n\t\t\tvar p = EmptyParams();\n\t\t\tmap_object(p, function(out, moduleName) {\n\t\t\t\tvar defs = jsfx.Module[moduleName].params;\n\t\t\t\tmap_object(defs, function(def, name) {\n\t\t\t\t\tif (def.C) {\n\t\t\t\t\t\tvar values = Object_keys(def.C);\n\t\t\t\t\t\tout[name] = values[(values.length * Math.random()) | 0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout[name] = Math.random() * (def.H - def.L) + def.L;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tp.Volume.Master = 0.4;\n\t\t\tp.Filter = {}; // disable filter, as it usually will clip everything\n\t\t\tRemoveEmptyParams(p);\n\t\t\treturn p;\n\t\t}\n\t};\n\n\t// GENERATORS\n\n\t// uniform noise\n\tjsfx.G.unoise = newGenerator(\"sample = Math.random();\");\n\t// sine wave\n\tjsfx.G.sine = newGenerator(\"sample = Math.sin(phase);\");\n\t// saw wave\n\tjsfx.G.saw = newGenerator(\"sample = 2*(phase/TAU - ((phase/TAU + 0.5)|0));\");\n\t// triangle wave\n\tjsfx.G.triangle = newGenerator(\"sample = Math.abs(4 * ((phase/TAU - 0.25)%1) - 2) - 1;\");\n\t// square wave\n\tjsfx.G.square = newGenerator(\"var s = Math.sin(phase); sample = s > A ? 1.0 : s < A ? -1.0 : A;\");\n\t// simple synth\n\tjsfx.G.synth = newGenerator(\"sample = Math.sin(phase) + .5*Math.sin(phase/2) + .3*Math.sin(phase/4);\");\n\n\t// STATEFUL\n\tvar __noiseLast = 0;\n\tjsfx.G.noise = newGenerator(\"if(phase % TAU < 4){__noiseLast = Math.random() * 2 - 1;} sample = __noiseLast;\");\n\n\t// Karplus-Strong string\n\tjsfx.G.string = {\n\t\tcreate: function() {\n\t\t\tvar BS = 1 << 16;\n\t\t\tvar BM = BS - 1;\n\n\t\t\tvar buffer = createFloatArray(BS);\n\t\t\tfor (var i = 0; i < buffer.length; i++) {\n\t\t\t\tbuffer[i] = Math.random() * 2 - 1;\n\t\t\t}\n\n\t\t\tvar head = 0;\n\t\t\treturn function($, block) {\n\t\t\t\tvar TAU = Math.PI * 2;\n\t\t\t\tvar A = +$.generatorA,\n\t\t\t\t\tASlide = +$.generatorASlide,\n\t\t\t\t\tB = +$.generatorB,\n\t\t\t\t\tBSlide = +$.generatorBSlide;\n\t\t\t\tvar buf = buffer;\n\n\t\t\t\tfor (var i = 0; i < block.length; i++) {\n\t\t\t\t\tvar phaseSpeed = block[i];\n\t\t\t\t\tvar n = (TAU / phaseSpeed) | 0;\n\t\t\t\t\tA += ASlide;\n\t\t\t\t\tB += BSlide;\n\t\t\t\t\tA = A < 0 ? 0 : A > 1 ? 1 : A;\n\t\t\t\t\tB = B < 0 ? 0 : B > 1 ? 1 : B;\n\n\t\t\t\t\tvar t = ((head - n) + BS) & BM;\n\t\t\t\t\tvar sample = (\n\t\t\t\t\t\tbuf[(t - 0 + BS) & BM] * 1 +\n\t\t\t\t\t\tbuf[(t - 1 + BS) & BM] * A +\n\t\t\t\t\t\tbuf[(t - 2 + BS) & BM] * B) / (1 + A + B);\n\n\t\t\t\t\tbuf[head] = sample;\n\t\t\t\t\tblock[i] = buf[head];\n\t\t\t\t\thead = (head + 1) & BM;\n\t\t\t\t}\n\n\t\t\t\t$.generatorA = A;\n\t\t\t\t$.generatorB = B;\n\t\t\t\treturn block.length;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Generates samples using given frequency and generator\n\tfunction newGenerator(line) {\n\t\treturn new Function(\"$\", \"block\", \"\" +\n\t\t\t\"var TAU = Math.PI * 2;\\n\" +\n\t\t\t\"var sample;\\n\" +\n\t\t\t\"var phase = +$.generatorPhase,\\n\" +\n\t\t\t\"\tA = +$.generatorA, ASlide = +$.generatorASlide,\\n\" +\n\t\t\t\"\tB = +$.generatorB, BSlide = +$.generatorBSlide;\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"for(var i = 0; i < block.length; i++){\\n\" +\n\t\t\t\"\tvar phaseSpeed = block[i];\\n\" +\n\t\t\t\"\tphase += phaseSpeed;\\n\" +\n\t\t\t\"\tif(phase > TAU){ phase -= TAU };\\n\" +\n\t\t\t\"\tA += ASlide; B += BSlide;\\n\" +\n\t\t\t\"   A = A < 0 ? 0 : A > 1 ? 1 : A;\\n\" +\n\t\t\t\"   B = B < 0 ? 0 : B > 1 ? 1 : B;\\n\" +\n\t\t\tline +\n\t\t\t\"\tblock[i] = sample;\\n\" +\n\t\t\t\"}\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"$.generatorPhase = phase;\\n\" +\n\t\t\t\"$.generatorA = A;\\n\" +\n\t\t\t\"$.generatorB = B;\\n\" +\n\t\t\t\"return block.length;\\n\" +\n\t\t\t\"\");\n\t}\n\n\t// WAVE SUPPORT\n\n\t// Creates an Wave byte array from audio data [-1.0 .. 1.0]\n\tjsfx.CreateWave = CreateWave;\n\n\tfunction CreateWave(data) {\n\t\tif (typeof Float32Array !== \"undefined\") {\n\t\t\tassert(data instanceof Float32Array, 'data must be an Float32Array');\n\t\t}\n\n\t\tvar blockAlign = numChannels * bitsPerSample >> 3;\n\t\tvar byteRate = jsfx.SampleRate * blockAlign;\n\n\t\tvar output = createByteArray(8 + 36 + data.length * 2);\n\t\tvar p = 0;\n\n\t\t// emits string to output\n\t\tfunction S(value) {\n\t\t\tfor (var i = 0; i < value.length; i += 1) {\n\t\t\t\toutput[p] = value.charCodeAt(i);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\t// emits integer value to output\n\t\tfunction V(value, nBytes) {\n\t\t\tif (nBytes <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toutput[p] = value & 0xFF;\n\t\t\tp++;\n\t\t\tV(value >> 8, nBytes - 1);\n\t\t}\n\t\t/* beautify preserve:start */\n\t\tS('RIFF'); V(36 + data.length * 2, 4);\n\n\t\tS('WAVEfmt '); V(16, 4); V(1, 2);\n\t\tV(numChannels, 2); V(jsfx.SampleRate, 4);\n\t\tV(byteRate, 4); V(blockAlign, 2); V(bitsPerSample, 2);\n\n\t\tS('data'); V(data.length * 2, 4);\n\t\tCopyFToU8(output.subarray(p), data);\n\t\t/* beautify preserve:end */\n\n\t\treturn output;\n\t};\n\n\t// Creates an Audio element from audio data [-1.0 .. 1.0]\n\tjsfx.CreateAudio = CreateAudio;\n\n\tfunction CreateAudio(data) {\n\t\tvar wave = CreateWave(data);\n\t\treturn new Audio('data:audio/wav;base64,' + U8ToB64(wave));\n\t};\n\n\tjsfx.DownloadAsFile = function(audio) {\n\t\tassert(audio instanceof Audio, 'input must be an Audio object');\n\t\tdocument.location.href = audio.src;\n\t};\n\n\t// HELPERS\n\tjsfx.Util = {};\n\n\t// Copies array of Floats to a Uint8Array with 16bits per sample\n\tjsfx.Util.CopyFToU8 = CopyFToU8;\n\n\tfunction CopyFToU8(into, floats) {\n\t\tassert(into.length / 2 == floats.length,\n\t\t\t'the target buffer must be twice as large as the iinput');\n\n\t\tvar k = 0;\n\t\tfor (var i = 0; i < floats.length; i++) {\n\t\t\tvar v = +floats[i];\n\t\t\tvar a = (v * 0x7FFF) | 0;\n\t\t\ta = a < -0x8000 ? -0x8000 : 0x7FFF < a ? 0x7FFF : a;\n\t\t\ta += a < 0 ? 0x10000 : 0;\n\t\t\tinto[k] = a & 0xFF;\n\t\t\tk++;\n\t\t\tinto[k] = a >> 8;\n\t\t\tk++;\n\t\t}\n\t}\n\n\t// Encodes Uint8Array with base64\n\tjsfx.Util.U8ToB64 = U8ToB64;\n\n\tfunction U8ToB64(data) {\n\t\tvar CHUNK = 0x8000;\n\t\tvar result = '';\n\t\tfor (var start = 0; start < data.length; start += CHUNK) {\n\t\t\tvar end = Math.min(start + CHUNK, data.length);\n\t\t\tresult += String.fromCharCode.apply(null, data.subarray(start, end));\n\t\t}\n\t\treturn btoa(result);\n\t}\n\n\t// uses AudioContext sampleRate or 44100;\n\tfunction getDefaultSampleRate() {\n\t\tif (typeof AudioContext !== 'undefined') {\n\t\t\treturn (new AudioContext()).sampleRate;\n\t\t}\n\t\treturn 44100;\n\t}\n\n\t// for checking pre/post conditions\n\tfunction assert(condition, message) {\n\t\tif (!condition) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n\n\tfunction clamp(v, min, max) {\n\t\tv = +v;\n\t\tmin = +min;\n\t\tmax = +max;\n\t\tif (v < min) {\n\t\t\treturn +min;\n\t\t}\n\t\tif (v > max) {\n\t\t\treturn +max;\n\t\t}\n\t\treturn +v;\n\t}\n\n\tfunction clamp1(v) {\n\t\tv = +v;\n\t\tif (v < +0.0) {\n\t\t\treturn +0.0;\n\t\t}\n\t\tif (v > +1.0) {\n\t\t\treturn +1.0;\n\t\t}\n\t\treturn +v;\n\t}\n\n\tfunction map_object(obj, fn) {\n\t\tvar r = {};\n\t\tfor (var name in obj) {\n\t\t\tif (obj.hasOwnProperty(name)) {\n\t\t\t\tr[name] = fn(obj[name], name);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\t// uniform random\n\tfunction runif(scale, offset) {\n\t\tvar a = Math.random();\n\t\tif (scale !== undefined)\n\t\t\ta *= scale;\n\t\tif (offset !== undefined)\n\t\t\ta += offset;\n\t\treturn a;\n\t}\n\n\tfunction rchoose(gens) {\n\t\treturn gens[(gens.length * Math.random()) | 0];\n\t}\n\n\tfunction Object_keys(obj) {\n\t\tvar r = [];\n\t\tfor (var name in obj) {\n\t\t\tr.push(name);\n\t\t}\n\t\treturn r;\n\t}\n\n\tjsfx._createFloatArray = createFloatArray;\n\n\tfunction createFloatArray(N) {\n\t\tif (typeof Float32Array === \"undefined\") {\n\t\t\tvar r = new Array(N);\n\t\t\tfor (var i = 0; i < r.length; i++) {\n\t\t\t\tr[i] = 0.0;\n\t\t\t}\n\t\t}\n\t\treturn new Float32Array(N);\n\t}\n\n\tfunction createByteArray(N) {\n\t\tif (typeof Uint8Array === \"undefined\") {\n\t\t\tvar r = new Array(N);\n\t\t\tfor (var i = 0; i < r.length; i++) {\n\t\t\t\tr[i] = 0 | 0;\n\t\t\t}\n\t\t}\n\t\treturn new Uint8Array(N);\n\t}\n\n\treturn jsfx;\n}));\n","import jsfx from \"loov-jsfx\";\n\nif (typeof AFRAME === \"undefined\") {\n  throw new Error(\n    \"Component attempted to register before AFRAME was available.\"\n  );\n}\n\nAFRAME.registerComponent(\"jsfx\", {\n\n  multiple: true,\n\n  schema: {\n    src: { type: \"asset\" },\n    sound: {},\n    event: { default: \"click\" },\n  },\n\n  update: function (old) {\n\n    // update src\n    if (!this.data.sound || old.src != this.data.src) {\n      // get json from asset\n      let config = JSON.parse(THREE.Cache.files[this.data.src]);\n\n      // create sound configuration from json entries\n      let sounds = Object.keys(config);\n      this.schema.sound.oneOf = sounds;\n      this.schema.sound.default = sounds[0];\n\n      // use first sound as default sound\n      if (!this.data.sound) {\n        this.el.setAttribute(\"jsfx\", \"sound\", this.schema.sound.default);\n      }\n\n      // init jsfx\n      this.jsfx = jsfx.Sounds(config);\n\n    }\n\n    // update current sound\n    this.sound = this.data.sound || sounds[0];\n        \n    // update event handler when playing\n    if (this.playing) {\n      this.removeEvent(old.event);\n      this.addEvent();\n    }\n  },\n\n  playSound(sound) {\n    this.jsfx[sound]();\n  },\n\n  addEvent: function () {\n    if (this.event) return;\n    this.event = () => {\n      this.playSound(this.sound);\n    };\n    let eventname = this.id || this.data.event;\n    this.el.addEventListener(eventname, this.event);\n  },\n\n  removeEvent: function (name) {\n    if (!this.event) return;\n    this.el.removeEventListener(name, this.event);\n    this.event = null;\n  },\n\n  pause: function () {\n    this.playing = false;\n    this.remove();\n  },\n\n  play: function () {\n    this.playing = true;\n    this.addEvent();\n  },\n\n  remove: function () {\n    this.removeEvent(this.data.event);\n  },\n});\n"]}